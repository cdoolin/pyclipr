from typing import Any, Literal, Never, overload

import numpy as np
import numpy.typing as npt

class PathType:
    Subject: PathType = ...
    Clip: PathType = ...

Subject: PathType = ...
Clip: PathType = ...

class ClipType:
    Union: ClipType = ...
    Difference: ClipType = ...
    Intersection: ClipType = ...
    Xor: ClipType = ...

Union: ClipType = ...
Difference: ClipType = ...
Intersection: ClipType = ...
Xor: ClipType = ...

class FillRule:
    EvenOdd: FillRule = ...
    NonZero: FillRule = ...
    Positive: FillRule = ...
    Negative: FillRule = ...

EvenOdd: FillRule = ...
NonZero: FillRule = ...
Positive: FillRule = ...
Negative: FillRule = ...

class JoinType:
    Square: JoinType = ...
    Round: JoinType = ...
    Miter: JoinType = ...

Square: JoinType = ...
Round: JoinType = ...
Miter: JoinType = ...

class EndType:
    Square: EndType = ...
    Butt: EndType = ...
    Joined: EndType = ...
    Polygon: EndType = ...
    Round: EndType = ...

Square: EndType = ...
Butt: EndType = ...
Joined: EndType = ...
Polygon: EndType = ...
Round: EndType = ...

clipperVersion: str = ...

class PolyPath:
    def __init__(self) -> Never: ...
    @property
    def level(self) -> int: ...
    @property
    def parent(self) -> PolyPath: ...

class PolyTree:
    def __init__(self) -> Never: ...
    @property
    def isHole(self) -> bool: ...
    @property
    def area(self) -> float: ...
    @property
    def attributes(self) -> npt.NDArray[np.float64]: ...
    @property
    def polygon(self) -> npt.NDArray[np.float64]: ...
    @property
    def children(self) -> list[PolyTree]: ...
    @property
    def count(self) -> int: ...
    def __len__(self) -> int: ...

class PolyTreeD:
    def __init__(self) -> Never: ...
    @property
    def isHole(self) -> bool: ...
    @property
    def area(self) -> float: ...
    @property
    def attributes(self) -> npt.NDArray[np.float64]: ...
    @property
    def polygon(self) -> npt.NDArray[np.float64]: ...
    @property
    def children(self) -> list[PolyTreeD]: ...
    @property
    def count(self) -> int: ...
    def __len__(self) -> int: ...

def polyTreeToPaths64(polytree: PolyTree) -> list[npt.NDArray[np.float64]]: ...
def orientation(path: npt.NDArray[np.float64], scaleFactor: float = 1000) -> bool: ...
def polyTreeToPathsD(polytree: PolyTreeD) -> list[npt.NDArray[np.float64]]: ...
def simplifyPath(
    path: npt.NDArray[np.float64], epsilon: float, isOpenPath: bool = False
) -> npt.NDArray[np.float64]: ...
def simplifyPaths(
    paths: list[npt.NDArray[np.float64]], epsilon: float, isOpenPath: bool = False
) -> list[npt.NDArray[np.float64]]: ...

class Clipper:
    scaleFactor: float
    preserveCollinear: bool

    def addPath(
        self, path: npt.NDArray[np.float64], pathType: PathType, isOpen: bool = False
    ) -> None: ...
    def addPaths(
        self,
        paths: list[npt.NDArray[np.float64]],
        pathType: PathType,
        isOpen: bool = False,
    ) -> None: ...
    @overload
    def execute(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: Literal[False] = False,
        returnZ: Literal[False] = False
    ) -> list[npt.NDArray[np.float64]]: ...
    @overload
    def execute(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: Literal[False] = False,
        returnZ: Literal[True] = True
    ) -> tuple[list[npt.NDArray[np.float64]], list[npt.NDArray[np.float64]]]: ...
    @overload
    def execute(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: Literal[True] = True,
        returnZ: bool = False
    ) -> tuple[list[npt.NDArray[np.float64]], list[npt.NDArray[np.float64]]]: ...
    @overload
    def execute(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: Literal[True] = True,
        returnZ: Literal[True] = True
    ) -> tuple[
        list[npt.NDArray[np.float64]],
        list[npt.NDArray[np.float64]],
        list[npt.NDArray[np.float64]],
        list[npt.NDArray[np.float64]],
    ]: ...
    @overload
    def execute2(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: Literal[False] = False,
        returnZ: bool = False
    ) -> PolyTreeD: ...
    @overload
    def execute2(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: Literal[True] = True,
        returnZ: bool = False
    ) -> tuple[PolyTreeD, list[npt.NDArray[np.float64]]]: ...
    @overload
    def execute2(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: Literal[True] = True,
        returnZ: Literal[True] = True
    ) -> tuple[
        PolyTreeD, list[npt.NDArray[np.float64]], list[npt.NDArray[np.float64]]
    ]: ...
    def executeTree(
        self,
        clipType: ClipType,
        fillRule: FillRule = FillRule.EvenOdd,
        *,
        returnOpenPaths: bool = False,
        returnZ: bool = False
    ) -> PolyTreeD: ...
    def clear(self) -> None: ...
    def cleanUp(self) -> None: ...

class ClipperOffset:
    scaleFactor: float
    arcTolerance: float
    miterLimit: float
    preserveCollinear: bool

    def addPath(
        self,
        path: npt.NDArray[np.float64],
        joinType: JoinType,
        endType: EndType = EndType.Polygon,
    ) -> None: ...
    def addPaths(
        self,
        paths: list[npt.NDArray[np.float64]],
        joinType: JoinType,
        endType: EndType = EndType.Polygon,
    ) -> None: ...
    def execute(self, delta: float) -> list[npt.NDArray[np.float64]]: ...
    def execute2(self, delta: float) -> PolyTreeD: ...
    def executeTree(self, delta: float) -> PolyTreeD: ...
    def clear(self) -> None: ...

__version__: str = ...
